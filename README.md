# bio-nio-aio
bio、nio demo学习
第一节主要学习单发单收，单个线程
第二节主要是多发多收

git config  user.name "498374215@qq.com"
git config user.email "498374215@qq.com"
-- git生成公钥
ssh-keygen -t rsa -C "498374215@qq.com"
cat ~/.ssh/id_rsa.pub
#zyb_project
小游戏项目

这个项目是从0到1的一个项目，目的是为了拉新裂变、首先分为几个系统，蜂鸟建站系统、抽奖系统、答题系统、任务系统，其中抽奖系统、答题系统是已有的功能，本次开发涉及到的是蜂鸟系统和任务系统的开发，整个项目分为b端和c端，b端蜂鸟侧主要通过在某一个游戏活动下配置游戏策略和游戏机会，前端新增任务组件，后端新增一些接口，整个项目分为游戏首页，获取更多机会、游戏进行页、游戏排行榜。由于游戏首页中需要给用户展示当前有几次机会，还要展示该用户当前可以玩第几关，哪关是已解锁的状态，哪几关是未解锁的状态，这个时候是前端多个组件并发请求一个接口，这个时候会造成在机会表中同时insert多条相同的记录，为了解决这个问题，采用的是redis分布式锁的方式来解决的，目的是将并发转为串行，一个进行强锁然后写入到机会表，数据源组件需要等锁，经过ab工具压测，首页整个页面耗时在50多毫秒，通过for循环去抢锁，最终给用户展示首页的内容。默认给用户一次机会，用户点击某一关进行游戏的时候，前端通过计算如果得的分数大于后台配置的抽奖分数，那么用户可以进行一次抽奖，这个时候如果用户恶意请求抽奖接口，可能会造成同一用户多次抽奖的情况，为了避免这个问题，采用的是db中的悲观锁，for update，默认隔离级别下rr为了防止幻读，会加一个间隙锁(gap锁)，这样就会造成一个问题，比如我想锁住用户a，但是这个时候b用户切好在表的间隙中，这个时候用户b也阻塞了，不合理，为了解决这个问题，在后面加一个limit 1的方式将间隙锁退化为行锁，因为游戏表中有几关就会展示几条记录，所以用户进入到游戏页，玩完一定会存在一条记录。抽奖结束后，可以查看排行榜，这个是针对某一关下的所有排行榜，分数从高到低。当用户机会用尽的时候，需要通过一下5种方式进行加机会，分享、邀请(需要打开链接并判断是否绑定过)、登陆、购课、关注公众号，具体加多少机会是在蜂鸟后台配置的，比如购课，支付后会发一个加课命令mq，任务系统去接收消息，然后调用蜂鸟系统加对应的机会。当前的qps也就几十，所以当时考虑的是db，项目的不足是，之后如果并发量比较大的时候，就需要加一层redis缓存来实现，减轻db的压力，任务系统本次主要是区分加机会的具体来源。整个项目的流程大概就是这样的。